Emily Claps and Samantha Rack
CSE 20211 Final Project
SSSSSSSnake

	In the user's perspective, when the program is run, "Welcome to Snake!" is displayed as well as the controls for the
up, down, right, and left directions. To pause the game, the user can press 'p', and to resume they can press 'r'. The user
is prompted to enter their name, which is read into a file to potentially use for a high score. They are then prompted to enter
a desired level (1-3). After the desired level is entered, the graphics window opens. The title "Snake" is displayed at the top of the window, and "Score" is displayed at the bottom with the appropriate numeric score as well. In level one, the snake begins at the middle of the screen and the user controls its movement with the 'w', 's', 'd', and 'a' keys to move it up, down, right, or left.
The goal is to move the snake in order to 'eat', or run into, the 4x4 pixel block randomly placed in the graphics window. Once
the block is eaten, a new block appears in a different random location. In level two, the same strategy is used but with the
addition of 8 barriers - 4 vertical and 4 horizontal. If the snake runs into any of these barriers, it dies and the game is over. In level three, the snake starts once again in the middle of the graphics window but has to maneuver around a maze. If the
snake runs into any of the walls of the maze, it dies. In all three levels, the snake can die if it runs into any edge of the
graphics window or itself. When the snake does die, its last position is displayed, the snake flashes red, and the window closes. The user score and high scores are then displayed in descending order in the command window. 
	Internally, most of the functions are called in 'main.' Once the size of the window and the inner boundary of the board & the parameters are initialized, the snake is set up with two arrays of snake_x and snake_y using the malloc command. Snake_x and snake_y contain the x and y position in the graphics window for each pixel of the snake
The snake's initial position is set up using the call of the function initialize_snake. For level 2, the function set_barriers
stores the values of each of the 8 barriers in the graphics window - 4 randomly placed vertical and 4 randomly placed horizontal. For level 3, the function set_maze stores the values of the maze that could be displayed. Once the parameters are set, printf statements are used to welcome the user and prompt the necessary inputs. New_block is used to store and display the values of the new randomly placed block that the snake tries to eat. Then in main, a 'while' loop is used for the entirety the game while the snake is alive. Each time through the loop, the appropriate functions print the border, title, score, snake, block, and barriers/maze for appropriate level. Nested 'for' loops with an 'if' statement are used to determine whether the head of the snake, or its 0th element, has intersected the coordinates of the block in the window. If so, the length is incremented and eat_block is called which uses 'realloc' to add an element to the snake array. A new block is randomly placed, and the score is updated (by 1 if level 1, 2 if level 2, 3 if level 3). The variable 'add_length_count' is then set at 5 and 
used in an 'if' statement to increase the length of the snake by 5 more pixels each time a block is eaten (so that additional lenth is noticeable). An 'if' statement with the function still_alive is used to check to see that the snake has not run into a boundary, itself, or a barrier/maze wall. If so, then game_over is called, which enters a 'for' loop to display the snake at its current location flashing red and then calls update_highscores and print_results, which show the user's score and whether or not it is in the highscores. While the snake is still alive, next_tick is called in each loop to move the snake by one pixel in its current direction. This function uses a 'for' loop to move each element down and compute the first element based on the direction parameter passed in. An 'if' statement with the gfx_event_waiting command is used to check to see if 'p' or 'r' or the direction keys were pressed by the user. User_action uses a switch statement to change the direction if it's a valid move. 'Counter' keeps track of how many times the 'while' loop has been traversed and is used to increase the speed as time goes on (to keep the speed at a reasonable level, the square root function was used). The speed of the snake is used to change 'dt', the amount of time it sleeps in each loop. Finally, after the 'while' loop, the free command is used for the snake_x and snake_y to free the memory on the heap at the end of the game. 
	The program was written gradually and tested one function at a time to ensure that any issues were resolved at the root of the problem. Printf statements were also used, especially when testing to make sure that the length of the snake was incremented properly each time a block was eaten. Boundary conditions, including those for high scores, barriers, the maze, etc. were tested vigorously. We also made sure that the appropriate level was opened in the graphics window when '1', '2', or '3' were entered in by the user. We tested invalid entries for the input from the user to see if the program responded as expected. We checked to see that the score displayed in the graphics window was incremented properly with the respective level and that it could reach up to three digits that were displayed. We checked to see that the snake flashed red, 'died', and the window closed when it (A) ran into itself, (B) ran into any of the four boundaries, and (C) ran into any of the barriers or maze walls. Since the drawn boundaries were randomly placed, to make sure that it wouldn't initially intersect with the snake, we divided up the placement of the barriers into quadrants with a gap between each quadrant (where the snake was first placed) to resolve this potential problem. Additionally, we increased the size of the block to 4x4 pixels so that no matter where it's placed, it was accessible despite the barriers or maze walls (which are 1 pixel wide). The speed was also increased in a reasonable manner so that the game was still playable after an extended period of time. Lastly, the high scores were displayed correctly and in descending order.  
