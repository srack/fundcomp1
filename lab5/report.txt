Samantha Rack
CSE 20211 Lab 5

When the user runs the program gallery.c, he or she views a gallery of 100 snowflakes on the screen.  These snowflakes are randomly placed on the screen and are randomly colored in grayscale.  If the user clicks with the mouse or types a letter other than 'q', the screen outputs a new set of 100 randomly colored and placed snowflakes.  The only other user interaction is typing the 'q' key, which terminates the program and closes the gfx window.  

From the perspective of writing the code, a recursive function, called fractal_snowflake, is placed within a for loop, which is inside a while loop.  The while loop is set to continue until keepgoing == 0 (when the user clicks 'q').  When the while loop ends, the main function returns 0, and the program finishes.  The for loop which contains the fractal_snowflake function is set to iterate 100 times (for each of the 100 snowflakes).  Within the for loop, the srand and rand functions are used to create differences between the 200 snowflakes.  srand seeds the rand function with respect to time for each time through the loop, so that the snowflakes do receive different randomly generated numbers.  The argument of srand, time(0)*counter*100, uses time(0) to make it random each time through the while loop (when the user completes an action), counter to make the seed different for each snowflake, and 100 to ensure the change in the seed since the iteration through the loop is rapid.  The rand function is then used to determine the (x, y) position of the snowflake (which is restricted to anywhere between 0 and xsize and 0 and ysize, respectively), the radius of the snowflake (restricted between 10 and 1/50th of xsize), the angle at which the first spoke of the snowflake is with respect to the x axis, the number of spokes (set between 5 and 10), and the color.  The color uses only one variable, used for r, b, and g, so that the snowflakes are in grayscale.  From there, the final step of the for loop calls fractal_snowflake to create the fractal with the given randomized parameters.  This for loop re-executes each time there is user interaction (unless this is 'q'), creating a new randomized scene of snowflakes on the screen.
Within the funciton, fractal_snowflake, there is additional randomization to account for variations in each specific snowflake.  fractal_snowflake first checks for the base case and returns if the radius is too small.  It then calls draw_spokes for its drawing step, which is the same function that is used for fractals.c (has no added variation).  The variation within fractal_snowflake occurs in the recursive step.  In determining newradius for the next iteration, rand, modulus, and the ternary operator are used to one third of the time produce a radius that is slightly larger than the other two thirds of the time.  Then, in the for loop that calls fractal_snowflake for the end of each spoke, the rand function is used within log10 to weight the random outcomes.  For the majority of the time, fractal_snowflake will be called at each end of the spoke, producing the expected results.  However, a small percentage of the time draw_fractal will not be called, and the spoke will end there.  Using another if statement with log10 and rand, a small percentage of the snowflakes are recursed with a greater number of spokes.  The final randomized element of fractal_snowflake changes theta (specified above) using fmod, rand, and dt. 

The program was checked for accuracy by first writing and running it with no randomization.  From there, the program's random elements were increased one by one and checked as they were written.  This made sure that they were accomplishing the randomization within the desired ranges and with the desired proportions.  
